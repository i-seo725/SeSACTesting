//
//  DI.swift
//  SeSACTesting
//
//  Created by 이은서 on 12/12/23.
//

import Foundation

//1. 브랜님이 브랜반점을 차림
//2. 브랜반점에서 휴님이 뭘 드심
//B(브랜반점)가 변화했을 때 A(휴님)에게 영향을 미침 => A가 B에 의존함

//휴님(상위모듈) -> 브랜반점(하위모듈) 형태로 의존 관계가 형성되어 있기 때문에,
//브랜반점에서의 코드 변화가 휴님에게 영향을 미치는 것을 확인할 수 있다
//하위모듈에서의 코드 변화가 상위모듈에게 영향을 미치는 것을 확인할 수 있다 => 유지보수가 어려움
// => 하위모듈의 변화가 상위모듈에 영향을 미치지 않게 하려면..? -> DI의 시작, 프로토콜을 통한 의존성 분리(타입으로서의 프로토콜)
// => 중국집, 중국집 주인장이 바뀌어도 휴님의 코드에는 영향이 없으려면?

//브랜반점과 코종반점이 중국집 프로토콜을 따르도록,
//브랜과 코코종은 주방장레시피 프로토콜을 따르도록 함
// => 구현체(콘크리트 타입)가 아닌 추상화(추상체-프로토콜)에 의존하도록 변경
// => 인터페이스(프로토콜)로 의존 관계 추상화

//DI: Dependency Injection, 의존성 주입
//DIP: Dependency Inversion Principle, 의존 역전 원칙

//이니셜라이저 시점에 주입을 하고,
//DI(의존성 주입)를 통해 객체의 생성과 사용을 분리
//DI를 한다고 해서 DIP를 준수하는 것은 아님
//DIP를 구현하는 기법 중 하나로 DI를 사용할 수 있음

//추상화, 구현체, 인터페이스, 프로토콜, 콘크리트 타입


protocol 중국집 {
    func 근사한점심메뉴() -> String
}

protocol 주방장레시피 {
    func 요리1() -> String
    func 요리2() -> String
    func 요리3() -> String
}



//하위모듈 (브랜반점 - 브랜 사이에서)
class 브랜: 주방장레시피 {
    func 요리1() -> String {
        return "브랜의 정성이 듬뿍 담긴 꿔바로우"
    }
    
    //국밥 -> 돈까스
    func 요리2() -> String {
        return "브랜의 최애 국밥말고 돈까스"
    }
    
    func 요리3() -> String {
        return "브랜의 을밀대"
    }
}


class 코코종: 주방장레시피 {
    func 요리1() -> String {
        return "코종의 특별한 소스가 들어간 탕수육"
    }
    
    func 요리2() -> String {
        return "마장동 한우 소머리국밥"
    }
    
    func 요리3() -> String {
        return "코종의 최애 밀면"
    }
}


//상위모듈 (브랜반점 - 브랜 사이에서)
//하위모듈 (휴님 - 브랜반점 사이에서)
class 브랜반점: 중국집 {
    private var 주인: 주방장레시피!
    
    //점심특선 -> 스페셜세트
    func 근사한점심메뉴() -> String {
        return 주인.요리1() + 주인.요리2() + 주인.요리3()
    }
}


class 코종반점: 중국집 {
    private var 주인: 주방장레시피
    
    init(주인: 주방장레시피) {
        self.주인 = 주인
    }
    
    func 근사한점심메뉴() -> String {
        return 주인.요리1() + 주인.요리2() + 주인.요리3()
    }
}



//상위모듈 (휴님 - 브랜반점 사이에서)
//코종반점의 생성 시점과 사용을 분리, 재사용이 높아지거나 가독성이 좋아짐, 클래스 내부에 인스턴스를 가지지 않음
//객체의 생성과 사용의 관심을 분리한다. 즉 생성자를 통해 의존성을 주입함
class 휴님 {
    //인스턴스를 생성하지 않고 프로토콜 타입을 받음
    var 중국집: 중국집
    
    init(중국집: 중국집) {
        self.중국집 = 중국집
    }
    
    func 점심밥() -> String {
        중국집.근사한점심메뉴()
    }
}

// => 구현체가 아닌 인터페이스 추상화에 의존한다
//인스턴스를 가지고 있을 때 테스트를 할 경우 어느 곳에 문제가 있는지 명확하지 않음

/*
 protocol NetworkProvider {
     func fetchLotto()
 }

 //네트워크 테스트를 할 때는 Mock 데이터를 통해 실제 통신을 하지 않고 테스트를 하는 것이 적합
 //Mock: 더미 응답 데이터
 //프로토콜 안의 메서드를 테스트

 class NetworkManager: NetworkProvider {
     
     func fetchLotto() { //실제 통신을 진행하는 부분
         //네트워크 코드
     }
  
     //인터넷 연결이 있어야만 테스트가 성공함 - 외부 환경에 영향을 받으면 안됨
     
 }
 */
